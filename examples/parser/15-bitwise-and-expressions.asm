; Test 15: Bitwise AND Expressions
; Tests the parser's ability to parse bitwise AND expressions.
; Bitwise AND operator: & (AND)

.org 0x2000

; Simple bitwise AND
test_bitwise_and:
    ld d0, 0xFF & 0x0F          ; 0x0F
    ld d0, 0xF0 & 0x0F          ; 0x00
    ld d0, 0xFFFF & 0x00FF      ; 0x00FF
    ld d0, 0xAAAA & 0x5555      ; 0x0000

; Chained bitwise AND (left-associative)
test_chained_and:
    ld d0, 0xFF & 0x0F & 0x03   ; (0xFF & 0x0F) & 0x03 = 0x0F & 0x03 = 0x03
    ld d0, 0xFFFF & 0xFF00 & 0x0F00 ; 0x0F00

; AND with grouped expressions
test_grouped_and:
    ld d0, (0xFF & 0x0F)
    ld d0, (0xFF & 0xF0) & 0x0F
    ld d0, 0xFF & (0xF0 & 0x0F)

; Bitwise AND has lower precedence than shift
; 0xFF & 1 << 4 parses as 0xFF & (1 << 4) = 0xFF & 0x10 = 0x10
test_precedence_shift:
    ld d0, 0xFF & 1 << 4        ; 0xFF & (1 << 4) = 0xFF & 0x10 = 0x10
    ld d0, 0x100 >> 4 & 0x0F    ; (0x100 >> 4) & 0x0F = 0x10 & 0x0F = 0x00

; Bitwise AND with additive (additive has higher precedence)
test_precedence_additive:
    ld d0, 0xFF & 0x0F + 0x10   ; 0xFF & (0x0F + 0x10) = 0xFF & 0x1F = 0x1F
    ld d0, 0x10 + 0x0F & 0xFF   ; (0x10 + 0x0F) & 0xFF = 0x1F & 0xFF = 0x1F

; Masking patterns
test_masking:
    ld d0, 0xDEADBEEF & 0xFF        ; Get low byte: 0xEF
    ld d0, 0xDEADBEEF & 0xFF00      ; Get second byte shifted: 0xBE00
    ld d0, 0xDEADBEEF & 0xFFFF      ; Get low word: 0xBEEF

; Data with bitwise AND expressions
.org 0x80000000
and_data:
.byte 0xFF & 0x0F, 0xAA & 0x55
.word 0xFFFF & 0x00FF, 0xAAAA & 0x5555
.dword 0xFFFFFFFF & 0x0000FFFF, 0xDEADBEEF & 0x0000FFFF

; Test 16: Bitwise XOR Expressions
; Tests the parser's ability to parse bitwise XOR expressions.
; Bitwise XOR operator: ^ (exclusive OR)

.org 0x2000

; Simple bitwise XOR
test_bitwise_xor:
    ld d0, 0xFF ^ 0x00          ; 0xFF
    ld d0, 0xFF ^ 0xFF          ; 0x00 (XOR with self = 0)
    ld d0, 0xAA ^ 0x55          ; 0xFF
    ld d0, 0xF0 ^ 0x0F          ; 0xFF

; Chained bitwise XOR (left-associative)
test_chained_xor:
    ld d0, 0xFF ^ 0x0F ^ 0xF0   ; (0xFF ^ 0x0F) ^ 0xF0 = 0xF0 ^ 0xF0 = 0x00
    ld d0, 0x12 ^ 0x34 ^ 0x56   ; Chained XOR

; XOR with grouped expressions
test_grouped_xor:
    ld d0, (0xFF ^ 0x0F)
    ld d0, (0xAA ^ 0x55) ^ 0xFF
    ld d0, 0xFF ^ (0x0F ^ 0xF0)

; XOR has lower precedence than bitwise AND
; 0xFF ^ 0x0F & 0xF0 parses as 0xFF ^ (0x0F & 0xF0) = 0xFF ^ 0x00 = 0xFF
test_precedence_and:
    ld d0, 0xFF ^ 0x0F & 0xF0   ; 0xFF ^ (0x0F & 0xF0) = 0xFF ^ 0x00 = 0xFF
    ld d0, 0xF0 & 0xFF ^ 0x0F   ; (0xF0 & 0xFF) ^ 0x0F = 0xF0 ^ 0x0F = 0xFF

; XOR patterns (toggle bits)
test_toggle:
    ld d0, 0xAAAAAAAA ^ 0xFFFFFFFF  ; Toggle all bits
    ld d0, 0x00 ^ 0xFF              ; Set bits
    ld d0, 0xFF ^ 0xFF              ; Clear all bits (result = 0)

; Double XOR recovers original value
; x ^ y ^ y = x
test_double_xor:
    ld d0, 0xDEAD ^ 0xBEEF ^ 0xBEEF ; Should give 0xDEAD

; Data with bitwise XOR expressions
.org 0x80000000
xor_data:
.byte 0xFF ^ 0x0F, 0xAA ^ 0x55
.word 0xFFFF ^ 0x0F0F, 0xAAAA ^ 0x5555
.dword 0xDEADBEEF ^ 0xFFFFFFFF, 0x12345678 ^ 0x87654321

/**
 * @file    g10asm/ast.hpp
 * @author  Dennis W. Griffin <dgdev1024@gmail.com>
 * @date    2025-12-22
 * 
 * @brief   Contains definitions for the G10 Assembler Tool's abstract syntax
 *          tree (AST) structures.
 */

#pragma once

/* Public Includes ************************************************************/

#include <g10/cpu.hpp>
#include <g10asm/token.hpp>

/* Public Constants and Enumerations ******************************************/

namespace g10asm
{
    /**
     * @brief   Strongly enumerates the types of abstract syntax tree (AST)
     *          nodes which can be generated by the G10 assembler tool's parser.
     */
    enum class ast_node_type
    {
        module,                 /** @brief The root node representing the entire module. */
        label_definition,       /** @brief An AST node representing the definition of an address label (`label:`). */
        instruction,            /** @brief An AST node representing a CPU instruction. */
        dir_org,                /** @brief An AST node representing an `.org` directive. */
        dir_rom,                /** @brief An AST node representing a `.rom` directive. */
        dir_ram,                /** @brief An AST node representing a `.ram` directive. */
        dir_int,                /** @brief An AST node representing a `.int` directive. */
        dir_byte,               /** @brief An AST node representing a `.byte` directive. */
        dir_word,               /** @brief An AST node representing a `.word` directive. */
        dir_dword,              /** @brief An AST node representing a `.dword` directive. */
        dir_global,             /** @brief An AST node representing a `.global` directive. */
        dir_extern,             /** @brief An AST node representing an `.extern` directive. */
        dir_let,                /** @brief An AST node representing a `.let` variable declaration directive. */
        dir_const,              /** @brief An AST node representing a `.const` constant declaration directive. */
        stmt_var_assignment,    /** @brief An AST node representing a variable assignment statement. */
        opr_immediate,          /** @brief An AST node representing an immediate operand (`52`, `0x34`). */
        opr_register,           /** @brief An AST node representing a register operand (`d0`, `w1`, `h2`, `l3`). */
        opr_condition,          /** @brief An AST node representing a branching condition operand (`nc`, `zs`, `cc`, `vs`). */
        opr_direct,             /** @brief An AST node representing a direct memory operand (`[0x1234]`). */
        opr_indirect,           /** @brief An AST node representing an indirect memory operand (`[d0]`, `[w1]`, `[l2]`). */
        expr_binary,            /** @brief An AST node representing a binary expression (e.g., `a + b`, `x * y`). */
        expr_unary,             /** @brief An AST node representing a unary expression (e.g., `-a`, `~b`). */
        expr_grouping,          /** @brief An AST node representing a grouped expression (e.g., `(a + b) * c`). */
        expr_primary            /** @brief An AST node representing a primary expression (identifier, literal, etc.). */
    };
}

/* Public Unions and Structures ***********************************************/

namespace g10asm
{
    /**
     * @brief   Forward declaration of the structure representing a base AST
     *          node for expressions.
     */
    struct ast_expression;

    /**
     * @brief   Defines a structure representing the base of an abstract syntax
     *          tree (AST) node.
     */
    struct ast_node
    {
        const bool              valid;          /** @brief Indicates whether this AST node is valid. */
        const ast_node_type     type;           /** @brief The type of this AST node. */
        const std::string_view  lexeme;         /** @brief The lexeme (string content) of the node's source token. */
        const std::string_view  source_file;    /** @brief The source file from which this node originated. */
        const std::size_t       source_line;    /** @brief The source line number at which this node originated. */
        const std::size_t       source_column;  /** @brief The source column number at which this node originated. */

    protected:
        explicit ast_node (const token& src_token, ast_node_type type) :
            valid           { true },
            type            { type },
            lexeme          { src_token.lexeme },
            source_file     { src_token.source_file },
            source_line     { src_token.source_line },
            source_column   { src_token.source_column }
        {}

        explicit ast_node (g10::cref<token> src_token, ast_node_type type) :
            valid           { true },
            type            { type },
            lexeme          { src_token.get().lexeme },
            source_file     { src_token.get().source_file },
            source_line     { src_token.get().source_line },
            source_column   { src_token.get().source_column }
        {}

        explicit ast_node (g10::result_cref<token> src_token_result, ast_node_type type) :
            valid           { src_token_result.has_value() },
            type            { type },
            lexeme          { src_token_result.has_value() ? src_token_result.value().get().lexeme : "" },
            source_file     { src_token_result.has_value() ? src_token_result.value().get().source_file : "" },
            source_line     { src_token_result.has_value() ? src_token_result.value().get().source_line : 0 },
            source_column   { src_token_result.has_value() ? src_token_result.value().get().source_column : 0 }
        {}

    };

    /**
     * @brief   A helper macro to quickly define an AST node's constructors.
     */
    #define ast_node_ctor(n, e) \
        explicit n (const token& src_token) : ast_node { src_token, e } {} \
        explicit n (g10::cref<token> src_token) : ast_node { src_token, e } {} \
        explicit n (g10::result_cref<token> src_token_result) : ast_node { src_token_result, e } {}

    /**
     * @brief   Defines a structure representing the root AST node for an entire
     *          G10 assembly module (object file).
     */
    struct ast_module final : public ast_node
    {
        ast_node_ctor(ast_module, ast_node_type::module)
        std::vector<std::unique_ptr<ast_node>> children;    /** @brief The list of child AST nodes contained within this module. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a label
     *          definition.
     * 
     * An address label consists of an identifier followed by a colon (`:`),
     * and marks a specific location in the code (as set by the assembler's
     * location counter) that can be referenced elsewhere in the code.
     * 
     * Address labels are commonly used as targets for jump and branch
     * instructions, allowing for control flow changes within the program. They
     * can also be used to define data locations or to mark specific points in
     * the code for organizational purposes.
     * 
     * Address labels can also be global or local in scope. Global labels can be
     * exported via the `.global` directive and imported via the `.extern`
     * directive, allowing them to be shared and referenced across multiple
     * assembly modules during the linking process. Local labels, on the other hand,
     * are only visible within the module in which they are defined.
     * 
     * Address labels can also be used in expressions and calculations, allowing
     * for more dynamic and flexible code. For example, an address label can be
     * used to calculate offsets or to define data structures.
     * 
     * Example 1 (basic usage):
     * ```asm
     * .org 0x2000          ; Set origin to address 0x2000 (in program ROM)
     * start:               ; Define label 'start' at current location (0x2000)
     *     ld d0, 0x10      ; Load immediate value 0x10 into dword register d0
     *     jpb nc, start    ; Jump relative back to 'start' (nc = no condition)
     * ```
     * 
     * Example 2 (referencing memory address):
     * ```asm
     * .org 0x80000000      ; Set origin to address 0x80000000 (in RAM)
     * counter:             ; Define label 'counter' at current location
     *                      ; (0x80000000)
     *     .word 1          ; Reserve one un-initialized (BSS) word at 'counter'
     * 
     * .org 0x2000          ; Set origin to address 0x2000 (in program ROM)
     * start:               ; Define label 'start' at current location (0x2000)
     *     ld w0, 0x00      ; Load immediate value 0x00 into word register w0
     *     st [counter], w0 ; Store value from w0 into memory at address 
     *                      ; 'counter'
     * loop:                ; Define label 'loop' at current location
     *     ld w0, [counter] ; Load word from memory at address 'counter' into w0
     *     inc w0           ; Increment the value in w0
     *     st [counter], w0 ; Store updated value from w0 back into memory at 
     *                      ; 'counter'
     *     jpb zc, loop     ; Jump relative back to 'loop' if zero flag is clear 
     *                      ; (zc = zero clear)
     * done:
     *     jpb done         ; Infinite loop to end program (no condition
     *                      ; explicitly specified = same as jpb nc, done)
     * ```
     * 
     * Example 3 (Using with `.global` and `extern` directives):
     * ```asm
     * ; File: module1.asm
     * .global main         ; Export 'main' label for use in other modules
     * .org 0x4000          ; Set origin to address 0x4000 (in program ROM)
     * main:                ; Define label 'main' at current location (0x4000)
     *     ld d0, 0x42      ; Load immediate value 0x42 into dword register d0
     *     jpb nc, main     ; Jump relative back to 'main' (nc = no condition)
     * 
     * ; File: module2.asm
     * .extern main         ; Import 'main' label from another module
     * .org 0x2000          ; Set origin to address 0x2000 (in program ROM)
     * start:               ; Define label 'start' at current location (0x2000)
     *     jmp main         ; Jump to 'main' label defined in module1.asm
     *                      ; (at address 0x4000; no condition explicitly
     *                      ; specified = same as jmp nc, main)
     * ```
     * 
     * Example 4 (Using in expressions):
     * ```asm
     * .org 0x4000          ; Set origin to address 0x4000 (in program ROM)
     * data_start:          ; Define label 'data_start' at current location (0x4000)
     *     .byte 0x01, 0x02, 0x03   ; Define some data bytes
     *     .byte 0x04, 0x05, 0x06
     * data_end:            ; Define label 'data_end' at current location
     * 
     * .org 0x2000          ; Set origin to address 0x2000 (in program ROM)
     * start:               ; Define label 'start' at current location (0x2000)
     *     ld d0, (data_end - data_start) ; Load size of data block into d0
     *     jpb nc, start    ; Jump relative back to 'start' (nc = no condition)
     * ```
     */
    struct ast_label_definition final : public ast_node
    {
        ast_node_ctor(ast_label_definition, ast_node_type::label_definition)
        std::string_view label_name;    /** @brief The name of the label being defined. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a CPU
     *          instruction.
     * 
     * CPU instructions are the fundamental building blocks of the G10
     * assembly language, representing the operations that the CPU can perform.
     * Each instruction corresponds to a specific operation code (opcode) that
     * the CPU recognizes and executes.
     * 
     * CPU instructions can have anywhere between zero and two operands,
     * depending on the specific instruction. Operands can be immediate values,
     * registers, memory addresses, or labels, and they provide the necessary
     * data or references for the instruction to operate on.
     * 
     * Example 1 (instruction with no operands):
     * ```asm
     * nop                  ; No Operation (no operands)
     * ```
     * 
     * Example 2 (instruction with operands):
     * ```asm
     * not w0               ; Bitwise NOT on word register w0 (one operand:
     *                      ; target register)
     * ld d0, 0x10          ; Load immediate value 0x10 into dword register d0
     *                      ; (two operands: destination register and immediate 
     *                      ; value)
     * ```
     * 
     * For the complete G10 CPU instruction set, please refer to the G10 CPU
     * Specification document (`./docs/g10cpu.spec.md`) and the G10 CPU header
     * file (`./projects/g10/cpu.hpp`).
     */
    struct ast_instruction final : public ast_node
    {
        ast_node_ctor(ast_instruction, ast_node_type::instruction)
        g10::instruction instruction;                       /** @brief The CPU instruction represented by this AST node. */
        std::vector<std::unique_ptr<ast_node>> operands;    /** @brief A list of AST nodes representing the instruction's operands, if any. */
    };

    /**
     * @brief   Defines a structure representing an AST node for an `.org`
     *          directive.
     * 
     * The `.org` directive is used to set the assembler's location counter to
     * a specific address in the assembled output. This directive allows the
     * programmer to control where subsequent code and data will be placed in
     * memory.
     * 
     * The address specified by the `.org` directive can be an absolute address
     * or an expression that evaluates to an address. Once the location counter
     * is set using the `.org` directive, all subsequent instructions and data
     * definitions will be placed starting from that address until another
     * `.org` directive is encountered or the end of the module is reached.
     * 
     * Example:
     * ```asm
     * .org 0x4000          ; Set origin to address 0x4000 (in program ROM)
     * start:               ; Define label 'start' at current location (0x4000)
     *     ld d0, 0x42      ; Load immediate value 0x42 into dword register d0
     * 
     * .org 0x80000000      ; Set origin to address 0x80000000 (in RAM)
     * buffer:              ; Define label 'buffer' at current location
     *                      ; (0x80000000)
     *     .byte 64         ; Reserve 64 bytes of un-initialized (BSS) space
     * ```
     */
    struct ast_dir_org final : public ast_node
    {
        ast_node_ctor(ast_dir_org, ast_node_type::dir_org)
        std::unique_ptr<ast_expression> address_expression;    /** @brief The AST node representing the address expression specified by this directive. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a `.rom`
     *          directive.
     * 
     * The `.rom` directive is used to switch the assembler's location counter
     * to the ROM region of the assembled output, where it last left off when
     * previously in ROM mode.
     * 
     * Example:
     * ```asm
     * .org 0x2000                  ; Set origin to address 0x2000 (in program ROM)
     *     .byte 0x01, 0x02, 0x03   ; Define some data bytes in ROM
     * .ram                         ; Switch to RAM region (here same as `.org 0x80000000`)
     *     .byte 64                 ; Reserve 64 bytes of un-initialized (BSS) space in RAM
     * .rom                         ; Switch back to ROM region (here same as `.org 0x2003`)
     *     .byte 0x04, 0x05, 0x06   ; Define more data bytes in ROM
     * .ram                         ; Switch back to RAM region (here same as `.org 0x80000040`)
     *     .byte 128                ; Reserve 128 bytes of un-initialized (BSS) space in RAM
     * ```
     */
    struct ast_dir_rom final : public ast_node
    {
        ast_node_ctor(ast_dir_rom, ast_node_type::dir_rom)
    };

    /**
     * @brief   Defines a structure representing an AST node for a `.ram`
     *          directive.
     * 
     * The `.ram` directive is used to switch the assembler's location counter
     * to the RAM region of the assembled output, where it last left off when
     * previously in RAM mode.
     * 
     * Example:
     * ```asm
     * .org 0x2000                  ; Set origin to address 0x2000 (in program ROM)
     *     .byte 0x01, 0x02, 0x03   ; Define some data bytes in ROM
     * .ram                         ; Switch to RAM region (here same as `.org 0x80000000`)
     *     .byte 64                 ; Reserve 64 bytes of un-initialized (BSS) space in RAM
     * .rom                         ; Switch back to ROM region (here same as `.org 0x2003`)
     *     .byte 0x04, 0x05, 0x06   ; Define more data bytes in ROM
     * .ram                         ; Switch back to RAM region (here same as `.org 0x80000040`)
     *     .byte 128                ; Reserve 128 bytes of un-initialized (BSS) space in RAM
     * ```
     */
    struct ast_dir_ram final : public ast_node
    {
        ast_node_ctor(ast_dir_ram, ast_node_type::dir_ram)
    };

    /**
     * @brief   Defines a structure representing an AST node for a `.int`
     *          directive.
     * 
     * The `.int` directive is a shorthand for setting the assembler's location
     * counter to the starting address of one of the G10's 32 interrupt vector
     * subroutines. Each interrupt vector subroutine occupies 0x80 (128) bytes
     * of space in the interrupt table region, starting at address $1000.
     * 
     * The directive takes a single integer argument specifying the vector
     * number (0-31). The location counter is set to the calculated address
     * of that vector: $1000 + (vector * 0x80).
     * 
     * Example:
     * ```asm
     * .int 0                       ; Set origin to $1000 (exception handler)
     * exception_handler:
     *     ; ... exception handling code ...
     *     stop
     * 
     * .int 3                       ; Set origin to $1180 (timer interrupt)
     * timer_isr:
     *     ; ... timer interrupt handling code ...
     *     reti
     * ```
     */
    struct ast_dir_int final : public ast_node
    {
        ast_node_ctor(ast_dir_int, ast_node_type::dir_int)

        /**
         * @brief   The expression specifying the interrupt vector number (0-31).
         */
        std::unique_ptr<ast_expression> vector_expression = nullptr;
    };

    /**
     * @brief   Defines a structure representing an AST node for a `.byte`
     *          directive.
     * 
     * The `.byte` directive is used to define, or reserve space for, one or
     * more bytes of data in the assembled output. This directive works
     * differently depending upon the current state of the assembler's location
     * counter:
     * 
     * - If the location counter is located in the ROM region (addresses
     *   `$00000000` to `$7FFFFFFF`), the `.byte` directive will define and emit
     *   the specified byte values directly into the program ROM area of the
     *   assembled output. In this case, the directive can accept byte values,
     *   strings (each character is treated as a byte; not null-terminated), or
     *   expressions that evaluate thereto.
     * 
     * - If the location counter is located in the RAM region (addresses
     *   `$80000000` to `$FFFFFFFF`), the `.byte` directive will reserve space
     *   for the specified number of un-initialized (BSS) bytes in the RAM area
     *   of the assembled output, but will not emit any actual byte values. In
     *   this case, the directive only accepts integer expressions that
     *   evaluate to the number of bytes to reserve. In the event of multiple
     *   arguments, their evaluated values are summed to determine the total
     *   number of bytes to reserve.
     * 
     * Example 1 (defining bytes in ROM):
     * ```asm
     * .org 0x4000                      ; Set origin to address 0x4000 
     *                                  ; (in program ROM)
     *     .byte 0x12, 0x34, 0x56, 0x78 ; Define four bytes: 0x12, 0x34,
     *                                  ; 0x56, 0x78    
     *     .byte "Hello, World!"        ; Define bytes for each character
     *                                  ; in the string (13 bytes)
     *     .byte 0x9A + 0xBC, 0xDE * 2  ; Define two bytes: 0x166 (0x9A +
     *                                  ; 0xBC = 0x166 -> 0x66), 0x1BC (0xDE * 2
     *                                  ; = 0x1BC -> 0xBC)
     * ```
     * 
     * Example 2 (reserving bytes in RAM):
     * ```asm
     * .org 0x80000000      ; Set origin to address 0x80000000 (in RAM)
     *     .byte 64         ; Reserve 64 bytes of un-initialized (BSS) space
     *     .byte 32 + 16    ; Reserve an additional 48 bytes (32 + 16)
     *     .byte 128 * 2    ; Reserve an additional 256 bytes (128 * 2)
     *     .byte 32, 128    ; Reserve an additional 160 bytes (32 + 128)
     * ```
     */
    struct ast_dir_byte final : public ast_node
    {
        ast_node_ctor(ast_dir_byte, ast_node_type::dir_byte)
        std::vector<std::unique_ptr<ast_node>> values;      /** @brief A list of AST nodes representing the byte values specified by this directive. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a `.word`
     *          directive.
     * 
     * The `.word` directive is used to define, or reserve space for, one or
     * more words (2 bytes each) of data in the assembled output. This directive
     * works differently depending upon the current state of the assembler's
     * location counter.
     * 
     * - If the location counter is located in the ROM region (addresses
     *   `$00000000` to `$7FFFFFFF`), the `.word` directive will define and emit
     *   the specified word values directly into the program ROM area of the
     *   assembled output. In this case, the directive can accept word values or
     *   expressions that evaluate thereto.
     * 
     * - If the location counter is located in the RAM region (addresses
     *   `$80000000` to `$FFFFFFFF`), the `.word` directive will reserve space
     *   for the specified number of un-initialized (BSS) words in the RAM area
     *   of the assembled output, but will not emit any actual word values. In
     *   this case, the directive only accepts integer expressions that
     *   evaluate to the number of words to reserve. In the event of multiple
     *   arguments, their evaluated values are summed to determine the total
     *   number of words to reserve.
     * 
     * Example 1 (defining words in ROM):
     * ```asm
     * .org 0x4000                  ; Set origin to address 0x4000 
     *                              ; (in program ROM)
     *     .word 0x1234, 0x5678     ; Define two words: 0x1234, 0x5678    
     *     .word 0x9ABC + 0xDEF0    ; Define one word: 0x8A2C (0x9ABC +
     *                              ; 0xDEF0 = 0x18A2C -> 0x8A2C)
     *     .word 0x1357 * 2         ; Define one word: 0x26AE (0x1357 * 2
     *                              ; = 0x26AE)
     * ```  
     * 
     * Example 2 (reserving words in RAM):
     * ```asm
     * .org 0x80000000    ; Set origin to address 0x80000000 (in RAM)
     *     .word 32       ; Reserve 32 words (64 bytes) of un-initialized
     *                    ; (BSS) space
     *     .word 16 + 8   ; Reserve an additional 24 words (48 bytes) (16 + 8)
     *     .word 64, 16   ; Reserve an additional 80 words (160 bytes) (64 + 16)
     * ```
     */
    struct ast_dir_word final : public ast_node
    {
        ast_node_ctor(ast_dir_word, ast_node_type::dir_word)
        std::vector<std::unique_ptr<ast_node>> values;      /** @brief A list of AST nodes representing the word values specified by this directive. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a `.dword`
     *          directive.
     * 
     * The `.dword` directive is used to define, or reserve space for, one or
     * more double words (4 bytes each) of data in the assembled output. This
     * directive works differently depending upon the current state of the
     * assembler's location counter.
     * 
     * - If the location counter is located in the ROM region (addresses
     *   `$00000000` to `$7FFFFFFF`), the `.dword` directive will define and
     *   emit the specified double word values directly into the program ROM
     *   area of the assembled output. In this case, the directive can accept
     *   double word values or expressions that evaluate thereto.
     * 
     * - If the location counter is located in the RAM region (addresses
     *   `$80000000` to `$FFFFFFFF`), the `.dword` directive will reserve space
     *   for the specified number of un-initialized (BSS) double words in the
     *   RAM area of the assembled output, but will not emit any actual double
     *   word values. In this case, the directive only accepts integer
     *   expressions that evaluate to the number of double words to reserve. In
     *   the event of multiple arguments, their evaluated values are summed to
     *   determine the total number of double words to reserve.
     * 
     * Example 1 (defining double words in ROM):
     * ```asm
     * .org 0x4000                      ; Set origin to address 0x4000 
     *                                  ; (in program ROM)
     *     .dword 0x12345678, 0x9ABCDEF0 ; Define two double words: 
     *                                  ; 0x12345678, 0x9ABCDEF0    
     *     .dword 0x11111111 + 0x22222222 ; Define one double word: 
     *                                  ; 0x33333333 (0x11111111 +
     *                                  ; 0x22222222 = 0x33333333)
     * ```  
     * 
     * Example 2 (reserving double words in RAM):
     * ```asm
     * .org 0x80000000      ; Set origin to address 0x80000000 (in RAM)
     *     .dword 16        ; Reserve 16 double words (64 bytes) of
     *                      ; un-initialized (BSS) space
     *     .dword 8 + 4     ; Reserve an additional 12 double words (48 bytes)
     *                      ; (8 + 4)
     *     .dword 32, 8     ; Reserve an additional 40 double words (160 bytes)
     *                      ; (32 + 8)
     * ```
     */
    struct ast_dir_dword final : public ast_node
    {
        ast_node_ctor(ast_dir_dword, ast_node_type::dir_dword)
        std::vector<std::unique_ptr<ast_node>> values;      /** @brief A list of AST nodes representing the dword values specified by this directive. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a `.global`
     *          directive.
     * 
     * The `.global` directive is used to declare one or more address labels
     * (symbols) as global, making them visible and accessible to other
     * assembly modules during the linking process. By declaring a label as
     * global, the assembler ensures that the label's address can be referenced
     * from other modules, allowing for inter-module communication and code
     * organization.
     * 
     * When a label is declared as global using the `.global` directive, it can
     * be exported from the current module and imported into other modules using
     * the `.extern` directive. This allows for modular programming, where
     * different parts of a program can be developed and assembled separately,
     * and then linked together to form a complete executable.
     * 
     * Example:
     * ```asm
     * .global main         ; Declare 'main' label as global
     * .org 0x4000          ; Set origin to address 0x4000 (in program ROM)
     * main:                ; Define label 'main' at current location (0x4000)
     *     ld d0, 0x42      ; Load immediate value 0x42 into dword register d0
     *     jpb nc, main     ; Jump relative back to 'main' (nc = no condition)
     * ```
     */
    struct ast_dir_global final : public ast_node
    {
        ast_node_ctor(ast_dir_global, ast_node_type::dir_global)
        std::vector<std::string_view> symbols;  /** @brief A list of label names (symbols) to be declared as global. */
    };

    /**
     * @brief   Defines a structure representing an AST node for an `.extern`
     *          directive.
     * 
     * The `.extern` directive is used to declare one or more address labels
     * (symbols) as external, indicating that their definitions are located in
     * other assembly modules. By declaring a label as external, the assembler
     * allows the current module to reference and use the label's address,
     * even though the label itself is not defined within the current module.
     * 
     * When a label is declared as external using the `.extern` directive, it
     * can be imported from other modules where it has been declared as global
     * using the `.global` directive. This enables inter-module communication
     * and code organization, allowing different parts of a program to be
     * developed and assembled separately, and then linked together to form a
     * complete executable.
     * 
     * Example:
     * ```asm
     * .extern main         ; Declare 'main' label as external
     * .org 0x2000          ; Set origin to address 0x2000 (in program ROM)
     * start:               ; Define label 'start' at current location (0x2000)
     *     jmp main         ; Jump to 'main' label defined in another module
     *                      ; (at address 0x4000; no condition explicitly
     *                      ; specified = same as jmp nc, main)
     * ```
     */
    struct ast_dir_extern final : public ast_node
    {
        ast_node_ctor(ast_dir_extern, ast_node_type::dir_extern)
        std::vector<std::string_view> symbols;  /** @brief A list of label names (symbols) to be declared as external. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a `.let`
     *          variable declaration directive.
     * 
     * The `.let` directive is used to declare a mutable assembler variable
     * with an initial value. Variables can be modified later using assignment
     * statements. Variable names are prefixed with `$` in source code.
     * 
     * Example:
     * ```asm
     * .let $counter = 0x10         ; Declare variable 'counter' with value 0x10
     * $counter += 5                ; Modify counter to 0x15
     * ld l0, $counter              ; Use variable value as immediate operand
     * ```
     */
    struct ast_dir_let final : public ast_node
    {
        ast_node_ctor(ast_dir_let, ast_node_type::dir_let)
        std::string_view variable_name;                     /** @brief The variable name (without the `$` prefix). */
        std::unique_ptr<ast_expression> init_expression;    /** @brief The initialization expression. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a `.const`
     *          constant declaration directive.
     * 
     * The `.const` directive is used to declare an immutable assembler constant
     * with a value. Constants cannot be modified after declaration. Constant
     * names are prefixed with `$` in source code.
     * 
     * Example:
     * ```asm
     * .const $MAX_VALUE = 0xFF     ; Declare constant 'MAX_VALUE' with value 0xFF
     * ld l0, $MAX_VALUE            ; Use constant value as immediate operand
     * ; $MAX_VALUE = 0x00          ; ERROR: Cannot modify a constant
     * ```
     */
    struct ast_dir_const final : public ast_node
    {
        ast_node_ctor(ast_dir_const, ast_node_type::dir_const)
        std::string_view constant_name;                     /** @brief The constant name (without the `$` prefix). */
        std::unique_ptr<ast_expression> value_expression;   /** @brief The constant value expression. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a variable
     *          assignment statement.
     * 
     * Variable assignment statements modify the value of a previously declared
     * variable using an assignment operator. Both simple assignment (`=`) and
     * compound assignment operators (`+=`, `-=`, `*=`, etc.) are supported.
     * 
     * Example:
     * ```asm
     * .let $value = 10             ; Declare variable
     * $value = 20                  ; Simple assignment
     * $value += 5                  ; Compound addition assignment
     * $value *= 2                  ; Compound multiplication assignment
     * ```
     */
    struct ast_stmt_var_assignment final : public ast_node
    {
        ast_node_ctor(ast_stmt_var_assignment, ast_node_type::stmt_var_assignment)
        std::string_view variable_name;                     /** @brief The target variable name (without the `$` prefix). */
        token_type assignment_operator;                     /** @brief The assignment operator (=, +=, -=, *=, etc.). */
        std::unique_ptr<ast_expression> value_expression;   /** @brief The right-hand side value expression. */
    };

    /**
     * @brief   Defines a structure representing an AST node for an immediate
     *          operand.
     * 
     * An immediate operand represents a constant value which typically (but
     * not always) appears directly after the instruction's opcode in the
     * assembly code. Immediate operands provide data that the instruction will
     * operate on, without requiring the use of registers or memory addresses to
     * hold the value.
     * 
     * Immediate operands can take various forms, including:
     * 
     * - Literal values: Numeric constants specified directly in the assembly
     *   code (e.g., `42`, `0x2A`).
     * 
     * - Character constants: Single characters enclosed in single quotes (e.g.,
     *   `'A'`, `'z'`), which are interpreted as their corresponding ASCII
     *   values.
     * 
     * - Expressions: Simple arithmetic or logical expressions that evaluate to
     *   a constant value (e.g., `5 + 3`, `0x10 << 2`).
     * 
     * Example:
     * ```asm
     * ld d0, 0x10      ; Load immediate value 0x10 into dword accumulator 
     *                  ; register d0
     * add w0, 42       ; Add immediate value 42 to word accumulator register w0
     * cmp l0, 'A'      ; Compare byte accumulator register l0 with immediate 
     *                  ; value 'A'
     * ```
     */
    struct ast_opr_immediate final : public ast_node
    {
        ast_node_ctor(ast_opr_immediate, ast_node_type::opr_immediate)
        std::unique_ptr<ast_expression> value;   /** @brief The AST node representing the immediate value of this operand. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a CPU register
     *          operand.
     * 
     * A register operand represents a CPU register that the instruction will
     * operate on. Registers are small, fast storage locations within the CPU
     * that hold data temporarily during instruction execution.
     * 
     * Register operands specify which register the instruction should use as a
     * source or destination for data. The G10 CPU architecture includes several
     * types of registers, including dword registers (`d0` to `d15`), partial
     * word registers (`w0` to `w15`), partial high byte registers (`h0` to
     * `h15`), and partial low byte registers (`l0` to `l15`). The accumulator
     * registers in the G10 CPU architecture are dword `d0`, word `w0` and
     * low byte `l0`.
     * 
     * Example:
     * ```asm
     * ld d0, 0x10      ; Load immediate value 0x10 into dword register d0
     * add w0, w1       ; Add value in word register w1 to word accumulator
     *                  ; register w0
     * not l2           ; Bitwise NOT on low byte register l2
     * ```
     * 
     * For more information on the G10 CPU registers, please refer to the G10
     * CPU Specification document (`./docs/g10cpu.spec.md`) and the G10 CPU
     * header file (`./projects/g10/cpu.hpp`).
     */
    struct ast_opr_register final : public ast_node
    {
        ast_node_ctor(ast_opr_register, ast_node_type::opr_register)
        g10::register_type reg;     /** @brief The CPU register represented by this operand. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a branching
     *          condition operand.
     * 
     * A condition operand specifies the branching condition for conditional
     * jump and branch instructions. These conditions determine whether the
     * instruction will cause a change in the program's control flow based on
     * the current state of the CPU's status flags.
     * 
     * The G10 CPU architecture supports several branching conditions, each
     * corresponding to specific combinations of the CPU's status flags (zero,
     * carry or overflow). Common conditions include:
     * 
     * - No Condition (`nc`): Unconditional jump or branch.
     * 
     * - Zero Set (`zs`): Jump or branch if the zero flag is set.
     * 
     * - Zero Clear (`zc`): Jump or branch if the zero flag is clear.
     * 
     * - Carry Set (`cs`): Jump or branch if the carry flag is set.
     * 
     * - Carry Clear (`cc`): Jump or branch if the carry flag is clear.
     * 
     * - Overflow Set (`vs`): Jump or branch if the overflow flag is set.
     * 
     * - Overflow Clear (`vc`): Jump or branch if the overflow flag is clear.
     * 
     * If a branching condition is encountered with no condition code explicitly
     * specified, it is treated as an unconditional jump or branch (equivalent to
     * `nc`). For instance: `jmp label` is equivalent to `jmp nc, label`, and
     * `ret` is equivalent to `ret nc`.
     * 
     * Example:
     * ```asm
     * jpb nc, label      ; Unconditional jump relative to 'label'
     * jpb zs, label      ; Jump relative to 'label' if zero flag is set
     * jmp cc, label      ; Jump to 'label' if carry flag is clear
     * call label         ; Call subroutine at 'label' (no condition explicitly
     *                    ; specified = same as call nc, label)
     * ```
     */
    struct ast_opr_condition final : public ast_node
    {
        ast_node_ctor(ast_opr_condition, ast_node_type::opr_condition)
        g10::condition_code condition;   /** @brief The branching condition represented by this operand. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a direct
     *          memory operand.
     * 
     * A direct memory operand specifies a memory address that the instruction
     * will access directly. This type of operand allows instructions to read
     * from or write to specific locations in memory.
     * 
     * Direct memory operands are integer-resolved expressions enclosed in
     * square brackets (e.g., `[0x1234]`, `[label + 4]`). The expression within
     * the brackets is evaluated to determine the exact memory address to be
     * accessed.
     * 
     * Example 1 (absolute memory addresses):
     * ```asm
     * ld d0, [0x80000000]  ; Load dword from memory address 0x80000000 into
     *                      ; dword register d0
     * st [0x80000004], d0  ; Store dword from dword register d0 into memory
     *                      ; address 0x80000004
     * ```
     * 
     * Example 2 (relative memory addresses):
     * ```asm
     * ldq w0, [0x4000]     ; Use `ldq` (Load Quick) to load data from a
     *                      ; relative 16-bit address (0x4000) into word
     *                      ; register w0. The effective address is relative
     *                      ; to absolute address 0xFFFF0000.
     * stq [0x4002], w0     ; Use `stq` (Store Quick) to store data from word
     *                      ; register w0 into a relative 16-bit address
     *                      ; (0x4002).
     * 
     * ldp b1, [0x60]       ; Use `ldp` (Load Port) to load data from a relative
     *                      ; 8-bit address (0x60) into byte register b1. The
     *                      ; effective address is relative to absolute address
     *                      ; 0xFFFFFF00.
     * stp [0x61], b1       ; Use `stp` (Store Port) to store data from byte
     *                      ; register b1 into a relative 8-bit address (0x61).
     * ```
     * 
     * Example 3 (labels and expressions):
     * ```asm
     * .org 0x80000000          ; Set origin to address 0x80000000 (in RAM)
     * data_start:              ; Define label 'data_start' at current location
     *                          ; (0x80000000)
     *     .dword 0xDEADBEEF    ; Define a dword at 'data_start'
     * data_end:                ; Define label 'data_end' at current location
     * 
     * .org 0x2000              ; Set origin to address 0x2000 (in program ROM)
     * start:                   ; Define label 'start' at current location
     *     ld d0, [data_start]  ; Load dword from memory address 'data_start'
     *                          ; (0x80000000) into dword register d0
     *     add d0, 0x1          ; Add immediate value 0x1 to dword register d0
     *     st [data_start], d0  ; Store updated dword from dword register d0 
     *                          ; back into memory address 'data_start' 
     *                          ; (0x80000000)
     *     ld d1, [data_end - 4]; Load dword from memory address 'data_end - 4'
     *                          ; (0x80000004 - size of one dword) into dword 
     *                          ; register d1
     *     jpb nc, start        ; Jump relative back to 'start' (nc = no 
     *                          ; condition)
     * ```
     */
    struct ast_opr_direct final : public ast_node
    {
        ast_node_ctor(ast_opr_direct, ast_node_type::opr_direct)
        std::unique_ptr<ast_expression> address;   /** @brief The AST node representing the direct memory address of this operand. */
    };

    /**
     * @brief   Defines a structure representing an AST node for an indirect
     *          memory operand.
     * 
     * An indirect memory operand specifies a memory address that is computed
     * using a base register and an optional offset. This type of operand allows
     * instructions to access memory locations relative to the value contained
     * in a CPU register.
     * 
     * Indirect memory operands are represented as a base register enclosed in
     * square brackets (e.g., `[d1]`, `[w2]`). The effective memory address is
     * determined by the value contained in the specified base register. The
     * G10 assembly language does not support offsets for indirect memory
     * operands; only the base register is used to compute the address.
     * 
     * Example:
     * ```asm
     * ld d0, [d1]      ; Load dword from memory address contained in dword
     *                  ; register d1 into dword register d0
     * stq [w2], w0     ; Store word from word register w0 into memory address
     *                  ; contained in word register w2 using `stq` (Store Quick)
     * ldp l1, [l3]     ; Load byte from memory address contained in byte
     *                  ; register l3 into byte register l1 using `ldp` (Load Port)
     * ```
     */
    struct ast_opr_indirect final : public ast_node
    {
        ast_node_ctor(ast_opr_indirect, ast_node_type::opr_indirect)
        g10::register_type base_register;           /** @brief The base register used for indirect memory addressing. */
    };

    /**
     * @brief   Defines a structure representing the base structure for all
     *          expression AST nodes.
     */
    struct ast_expression : public ast_node
    {
    protected:
        explicit ast_expression (const token& src_token, ast_node_type type) :
            ast_node { src_token, type }
        {}

        explicit ast_expression (g10::cref<token> src_token, ast_node_type type) :
            ast_node { src_token, type }
        {}

        explicit ast_expression (g10::result_cref<token> src_token_result, ast_node_type type) :
            ast_node { src_token_result, type }
        {}
    };

    /**
     * @brief   Helper macro to define constructors for AST expression nodes.
     */
    #define ast_expr_ctor(n, e) \
        explicit n (const token& src_token) : ast_expression { src_token, e } {} \
        explicit n (g10::cref<token> src_token) : ast_expression { src_token, e } {} \
        explicit n (g10::result_cref<token> src_token_result) : ast_expression { src_token_result, e } {}

    /**
     * @brief   Defines a structure representing an AST node for a binary
     *          expression.
     * 
     * A binary expression consists of two operands and a binary operator that
     * operates on those operands. The operator defines the type of operation to
     * be performed, such as addition, subtraction, multiplication, division,
     * bitwise operations, and more.
     * 
     * Binary expressions can be used in various contexts within the assembly
     * code, such as in immediate operands, direct memory addresses, and other
     * expressions. They allow for more complex calculations and evaluations to
     * be performed directly within the assembly code. Binary expressions can
     * be chained together to form more complex expressions, with the order of
     * operations determined by operator precedence and parentheses.
     * 
     * Example:
     * ```asm
     * ld d0, (5 + 3)       ; Load the result of the binary expression (5 + 3)
     *                      ; into dword register d0
     * st w0, (0x10 * 4)    ; Store the result of the binary expression (0x10 * 4)
     *                      ; into word register w0
     * cmp l0, (b1 & 0xFF)  ; Compare byte register l0 with the result of the
     *                      ; binary expression (b1 & 0xFF)
     * ```
     */
    struct ast_expr_binary final : public ast_expression
    {
        ast_expr_ctor(ast_expr_binary, ast_node_type::expr_binary)
        token_type operator_type;                          /** @brief The token type of the binary operator token. */
        std::unique_ptr<ast_expression> left_operand;      /** @brief The left operand of the binary expression. */
        std::unique_ptr<ast_expression> right_operand;     /** @brief The right operand of the binary expression. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a unary
     *          expression.
     * 
     * A unary expression consists of a single operand and a unary operator
     * that operates on that operand. The operator defines the type of operation
     * to be performed, such as negation, bitwise NOT, and more.
     * 
     * Unary expressions can be used in various contexts within the assembly
     * code, such as in immediate operands, direct memory addresses, and other
     * expressions. They allow for simple operations to be performed directly
     * within the assembly code.
     * 
     * Example:
     * ```asm
     * ld w0, -5          ; Load the result of the unary expression (-5) into
     *                    ; word register w0
     * ld b1, ~0xFF       ; Load the result of the unary expression (~0xFF)
     *                    ; into byte register b1
     * ```
     */
    struct ast_expr_unary final : public ast_expression
    {
        ast_expr_ctor(ast_expr_unary, ast_node_type::expr_unary)
        token_type operator_type;                  /** @brief The token type of the unary operator token. */
        std::unique_ptr<ast_expression> operand;   /** @brief The operand of the unary expression. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a grouping
     *          expression.
     * 
     * A grouping expression is used to group sub-expressions together using
     * parentheses. This allows for explicit control over the order of
     * operations within complex expressions, overriding the default operator
     * precedence rules.
     * 
     * Grouping expressions can be nested within other expressions, allowing
     * for the creation of complex mathematical and logical expressions in the
     * assembly code.
     * 
     * Example:
     * ```asm
     * ; Load the result of the grouping expression (5 + (3 * 2)) into
     * ; dword register d0
     * ld d0, (5 + (3 * 2))
     * 
     * ; Store the value of register w0 into the memory address defined by the
     * ; grouping expression ([0x80000000 + (16 * 4)])
     * st [0x80000000 + (16 * 4)], w0   
     * ```
     */
    struct ast_expr_grouping final : public ast_expression
    {
        ast_expr_ctor(ast_expr_grouping, ast_node_type::expr_grouping)
        std::unique_ptr<ast_expression> inner_expression;   /** @brief The inner expression contained within the grouping. */
    };

    /**
     * @brief   Defines a structure representing an AST node for a primary
     *          expression.
     * 
     * A primary expression is the simplest form of expression in the G10 Assembly
     * Language, representing literal values or identifiers that serve as the
     * building blocks for more complex expressions. These include:
     * 
     * - Integer literals (e.g., `42`, `0x2A`, `0b101010`)
     * - Number literals (e.g., `3.14`, `0.001`)
     * - Character literals (e.g., `'A'`, `'\n'`)
     * - String literals (e.g., `"Hello, World!"`)
     * - Identifiers (e.g., labels like `main`, variables like `$counter`,
     *      placeholders like `@1` or `@temp`)
     * 
     * Primary expressions do not contain sub-expressions or operators; they are
     * the atomic units of evaluation.
     * 
     * Example:
     * ```asm
     * ld d0, 0x10          ; `0x10` is a primary expression (integer literal)
     * ld w0, label         ; `label` is a primary expression (identifier)
     * ld b0, 'A'           ; `'A'` is a primary expression (character literal)
     * ```
     */
    struct ast_expr_primary final : public ast_expression
    {
        ast_expr_ctor(ast_expr_primary, ast_node_type::expr_primary)

        enum class primary_type
        {
            integer_literal,
            number_literal,
            char_literal,
            string_literal,
            identifier,
            variable,
            placeholder
        } expr_type; /** @brief The specific type of primary expression represented by this AST node. */

        /**
         * @brief   The value of the primary expression, stored as a variant to
         *          accommodate the different possible types.
         */
        std::variant<
            std::monostate,                     // For unparsed, unknown or invalid primary expressions
            int64_t,                            // Integer literal
            double,                             // Number literal
            char,                               // Character literal
            std::string_view                    // String literals, identifiers
        > value;

    };

    /**
     * @brief   A helper function to retrieve a human-readable string
     *          representation of an AST node.
     * 
     * @param   node    A handle to the AST node to be stringified.
     * @param   indent  The number of spaces to indent each line of the output
     *                  string. Defaults to `0` (no indentation).
     * 
     * @return  The string representation of the AST node.
     */
    auto ast_to_string (const ast_node& node, int indent = 0) -> std::string;

    /**
     * @brief   A helper function to retrieve a human-readable string
     *          representation of an AST expression node.
     * 
     * @param   node    A handle to the AST expression node to be stringified.
     * @param   indent  The number of spaces to indent each line of the output
     *                  string. Defaults to `0` (no indentation).
     * 
     * @return  The string representation of the AST expression node.
     */
    auto ast_to_string (const ast_expression& node, int indent = 0) 
        -> std::string;

    #undef ast_expr_ctor
    #undef ast_node_ctor
}
